# -*- coding: utf-8 -*-
"""Toc practs.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1L-El0v0op6f32bsRdzI9g2AcYh2U5gqc
"""

#Practical 2 
#Write a program for generating regular expressions for regular grammar
import re

line = "horses are taller than dogs"

searchObj = re.search(r'(.*) are (.*?) .*', line, re.M|re.I)

if searchObj:
    print("searchObj.group() : ", searchObj.group())
    print("searchObj.group(1) : ", searchObj.group(1))
    print("searchObj.group(2) : ", searchObj.group(2))
else:
    print("Nothing found!!")
------------------------------------------------------------------------------------
#Write a program for generating derivation sequence / language for the given sequence of
#productions
#practical 3
def printArray(arr, size):
    for i in range(size):
        print(arr[i], end=" ")
    print()

def getSuccessor(arr, k, n):
    # start from the rightmost side and find the first number less than n
    p = k - 1
    while (arr[p] == n and 0 <= p < k):
        p -= 1
    # If all numbers are n in the array then there is no successor, return 0
    if (p < 0):
        return 0
    # Update arr[] so that it contains successor
    arr[p] = arr[p] + 1
    i = p + 1
    while(i < k):
        arr[i] = 1
        i += 1
    return 1

def printSequences(n, k):
    arr = [0] * k
    # Initialize the current sequence as the first sequence to be printed
    for i in range(k):
        arr[i] = 1
    # The loop breaks when there are no more successors to be printed
    while(1):
        # Print the current sequence
        printArray(arr, k)
        # Update arr[] so that it contains next sequence to be printed. And if there are no more sequences then break the loop
        if(getSuccessor(arr, k, n) == 0):
            break

# Driver code
n = 4
k = 2
printSequences(n, k)
--------------------------------------------------------------------------------------
#practical4
#Design a Program for creating machine that accepts three consecutive one.
def acceptThreeConsecutiveOnes(input_str):
    state = 0
    for ch in input_str:
        if state == 0:
            if ch == '1':
                state = 1
        elif state == 1:
            if ch == '1':
                state = 2
            else:
                state = 0
        elif state == 2:
            if ch == '1':
                return True
            else:
                state = 0
    return False

input_str = "110101111001111"

if acceptThreeConsecutiveOnes(input_str):
    print("The string contains three consecutive ones!")
else:
    print("The string does not contain three consecutive ones.")
---------------------------------------------------------------------------------------
#practical 4
# Python3 implementation of the
# DFA of permutation of three
# a's and three b's

# State A
def stateA(n):
	if(n[0]=='a'):
		stateB(n[1:])
	elif (n[0]=='b'):
		stateH(n[1:])

# State B
def stateB(n):
	if(len(n)== 0):
		print("String Not Accepted")
	else:
		if(n[0]=='a'):
			stateC(n[1:])
		elif (n[0]=='b'):
			stateI(n[1:])

# State C
def stateC(n):
	if(len(n)== 0):
		print("String Not Accepted")
	else:
		if(n[0]=='a'):
			stateD(n[1:])
		elif (n[0]=='b'):
			stateJ(n[1:])

# State D
def stateD(n):
	if(len(n)== 0):
		print("String Not Accepted")
	else:
		if(n[0]=='a'):
			stateQ2(n)
		elif (n[0]=='b'):
			stateE(n[1:])
		
# State E
def stateE(n):
	if(len(n)== 0):
		print("String Not Accepted")
	else:
		if(n[0]=='a'):
			stateQ2(n)
		elif (n[0]=='b'):
			stateF(n[1:])
	
# State F
def stateF(n):
	if(len(n)== 0):
		print("String Not Accepted")
	else:
		if(n[0]=='a'):
			stateQ2(n[1:])
		elif (n[0]=='b'):
			stateG(n[1:])	
			
# State G
def stateG(n):
	if(len(n)== 0):
		print("String Accepted")
	else:
		if(n[0]=='a'):
			stateQ2(n)
		elif (n[0]=='b'):
			stateQ2(n)
			
# State H
def stateH(n):
	if(len(n)== 0):
		print("String Not Accepted")
	else:
		if(n[0]=='a'):
			stateI(n[1:])
		elif (n[0]=='b'):
			stateK(n[1:])
			
# State I
def stateI(n):
	if(len(n)== 0):
		print("String Not Accepted")
	else:
		if(n[0]=='a'):
			stateJ(n[1:])
		elif (n[0]=='b'):
			stateL(n[1:])

# State J
def stateJ(n):
	if(len(n)== 0):
		print("String Not Accepted")
	else:
		if(n[0]=='a'):
			stateE(n[1:])
		elif (n[0]=='b'):
			stateM(n[1:])		
			
# State K
def stateK(n):
	if(len(n)== 0):
		print("String Not Accepted")
	else:
		if(n[0]=='a'):
			stateL(n[1:])
		elif (n[0]=='b'):
			stateN(n[1:])
			
# State L
def stateL(n):
	if(len(n)== 0):
		print("String Not Accepted")
	else:
		if(n[0]=='a'):
			stateM(n[1:])
		elif (n[0]=='b'):
			stateO(n[1:])
			
# State M
def stateM(n):
	if(len(n)== 0):
		print("String Not Accepted")
	else:
		if(n[0]=='a'):
			stateF(n[1:])
		elif (n[0]=='b'):
			stateP(n[1:])		

# State N
def stateN(n):
	if(len(n)== 0):
		print("String Not Accepted")
	else:
		if(n[0]=='a'):
			stateO(n[1:])
		elif (n[0]=='b'):
			stateQ1(n)
			
# State Q
def stateO(n):
	if(len(n)== 0):
		print("String Not Accepted")
	else:
		if(n[0]=='a'):
			stateP(n[1:])
		elif (n[0]=='b'):
			stateQ1(n)
			
# State P
def stateP(n):
	if(len(n)== 0):
		print("String Not Accepted")
	else:
		if(n[0]=='a'):
			stateG(n[1:])
		elif (n[0]=='b'):
			stateQ1(n[1:])	
			
# State Q1
def stateQ1(n):
	print("String Not Accepted")

# State Q2
def stateQ2(n):
	print("String Not Accepted")

# take string input
n = "abaabb"

# call stateA
# to check the input
stateA(n)
---------------------------------------------------------------------------------------
#practical 5
#Design a Program for creating machine that accepts the string always ending with 101.
def acceptAlwaysEndsWith101(input_str):
    state = 0
    for ch in input_str:
        if state == 0:
            if ch == '1':
                state = 1
            else:
                state = 0
        elif state == 1:
            if ch == '0':
                state = 2
            elif ch == '1':
                state = 1
            else:
                state = 0
        elif state == 2:
            if ch == '1':
                state = 3
            elif ch == '0':
                state = 2
            else:
                state = 0
        elif state == 3:
            if ch == '1':
                state = 1
            elif ch == '0':
                state = 2
            else:
                state = 0
    return state == 3

input_str = "11010101101"

if acceptAlwaysEndsWith101(input_str):
    print("The string always ends with 101!")
else:
    print("The string does not always end with 101.")
---------------------------------------------------------------------------------------
#practical 5
def acceptEndingWith0101(input_str):
    state = 0
    for ch in input_str:
        if state == 0:
            if ch == '0':
                state = 1
            elif ch == '1':
                state = 2
        elif state == 1:
            if ch == '1':
                state = 3
            elif ch == '0':
                state = 2
            else:
                state = 0
        elif state == 2:
            if ch == '0':
                state = 3
            elif ch == '1':
                state = 1
            else:
                state = 0
        elif state == 3:
            if ch == '0' or ch == '1':
                state = 3
            else:
                state = 0
    return state == 3


# test cases
input_str1 = "00101"
input_str2 = "11010"
input_str3 = "11110"
input_str4 = "00000"

if acceptEndingWith0101(input_str1):
    print(input_str1 + " is accepted.")
else:
    print(input_str1 + " is rejected.")
    
if acceptEndingWith0101(input_str2):
    print(input_str2 + " is accepted.")
else:
    print(input_str2 + " is rejected.")

if acceptEndingWith0101(input_str3):
    print(input_str3 + " is accepted.")
else:
    print(input_str3 + " is rejected.")

if acceptEndingWith0101(input_str4):
    print(input_str4 + " is accepted.")
else:
    print(input_str4 + " is rejected.")
---------------------------------------------------------------------------------------
#practical6
#Design a program for accepting decimal number divisible by 2.
def dfa(input_string):
    state = "q0"
    for i in range(len(input_string)):
        if state == "q0":
            if input_string[i] == "0":
                state = "q0"
            elif input_string[i] == "1":
                state = "q1"
            else:
                return False
        elif state == "q1":
            if input_string[i] == "0":
                state = "q2"
            elif input_string[i] == "1":
                state = "q1"
            else:
                return False
        elif state == "q2":
            if input_string[i] == "0":
                state = "q0"
            elif input_string[i] == "1":
                state = "q1"
            else:
                return False
    if state == "q0":
        return True
    else:
        return False
--------------------------------------------------------------------------------------
#practical 6
def stateq0(n):
	#if length found 0
	#print not accepted
	if (len(n)==0):
		print("string accepted")
	else:
		
		#if at index 0
		#'0' found call
		#function stateq0
		if(n[0]=='0'):
			stateq0(n[1:])
			
		#else if '1' found
		#call function q1.
		elif (n[0]=='1'):
			stateq1(n[1:])

def stateq1(n):
	#if length found 0
	#print not accepted
	if (len(n)==0):
		print("string not accepted")
	else:
		
		#if at index 0
		#'0' found call
		#function stateq0
		if(n[0]=='0'):
			stateq0(n[1:])
			
		#else if '1' found
		#call function q1.
		elif (n[0]=='1'):
			stateq1(n[1:])		
		

#take number from user
n=int(input())
#converting number to binary
n = bin(n).replace("0b", "")

#call stateA
#to check the input
stateq0(n)
